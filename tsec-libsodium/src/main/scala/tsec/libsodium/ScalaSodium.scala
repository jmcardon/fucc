package tsec.libsodium

import cats.effect.Sync
import org.log4s._
import tsec.internal._
import tsec.jni._

/** Our libsodium interface class
  * Copied to scala from the java version that interfaces with the JNI code, generated by swig.
  */
final class ScalaSodium private extends ScalaSodium0

object ScalaSodium
    extends Argon2Constants
    with GenericHashConstants
    with ShortHashConstants
    with HmacSha256Constants
    with HmacSha512Constants
    with HmacSha512256Constants
    with SCryptConstants
    with SecretBoxConstants
    with CryptoAEADConstants
    with OriginalChacha20Poly1305Constants
    with Chacha20Poly1305IETFConstants
    with XChacha20Poly1305IETFConstants
    with KeyDerivationConstants
    with KxConstants
    with OnetimeAuthConstants
    with PKCryptoConstants {

  private[this] val logger = getLogger("tsec.scala-sodium")

  /** This is primarily for methods
    * which take an `unsigned long long*` or
    * anything else in which we can
    * typically pass a NULL in C, for swig typemaps.
    *
    */
  private[tsec] val NullPtrInt   = Array[Int](0)
  private[tsec] val NullPtrBytes = Array[Byte](0)

  /** Our swig compiled lib name **/
  private val libraryName = "sodiumjni"

  /** Check the sodium version is compatible with the api's we're using **/
  private def checkVersion(sodiumString: String): Unit = {
    val error = new SodiumLoadError(s"Unsupported libsodium version $sodiumString. Please upgrade to version 1.0.12+")

    sodiumString.trim.split("\\.") match {
      case Array(major, med, minor) =>
        if (major.toInt < 1 || (minor.toInt < 12 && med.toInt == 0)) {
          logger.error(error)("Unsupported version")
          throw error
        } else
          logger.info("Loading libsodium jni... Hold tight Asznee")
      case _ =>
        logger.error(error)("Unsupported version")
        throw error
    }
  }

  private[tsec] lazy val Sodium: ScalaSodium = {
    System.loadLibrary(libraryName)
    val sodium = new ScalaSodium()
    checkVersion(SodiumJNI.sodium_version_string.asInstanceOf[String])
    if (sodium.sodium_init < 0) {
      val err = new SodiumLoadError("Has not been initialized properly")
      logger.error(err)("ScalaSodium has not been initialized properly")
      throw err
    }
    logger.info("Libsodium loaded properly")

    sodium
  }

  final def getSodiumUnsafe: ScalaSodium = Sodium

  final def getSodium[F[_]](implicit F: Sync[F]): F[ScalaSodium] = F.delay(Sodium)

  final def randomBytes[F[_]](len: Int)(implicit F: Sync[F], S: ScalaSodium): F[Array[Byte]] = F.delay {
    val bytes = new Array[Byte](len)
    S.randombytes_buf(bytes, len)
    bytes
  }

  final def randomBytesUnsafe(len: Int)(implicit S: ScalaSodium): Array[Byte] = {
    val bytes = new Array[Byte](len)
    S.randombytes_buf(bytes, len)
    bytes
  }

  private final class SodiumLoadError(reason: String) extends VirtualMachineError {
    override def getMessage: String = reason
  }

}
